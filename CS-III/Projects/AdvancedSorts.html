<!DOCTYPE html>
<html lang= "en">
  <head>
    <link rel="stylesheet" type="text/css" href="../../assets/links.css">
    <link rel="stylesheet" type="text/css" href="../../assets/styles.css"> 
    <meta charset="UTF-8">
    
    <title>Advanced Sort-Pranav Krishnan</title>
    <link rel="icon" href="../../assets/pranavkrishnanlogo.png">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            padding: 20px;
        }
        h1, h2 {
            text-align: center;
        }
        h1 {
            margin-bottom: 20px;
        }
        h2 {
            margin-top: 30px;
            margin-bottom: 10px;
        }
        p {
            margin-bottom: 15px;
        }
      img {

	  border: 5px solid grey;

      }
      .center {
	  display: block;
	  margin-left: auto;
	  margin-right: auto;
	  width: 90%;
      } 
    h3{
	text-align: center;
	font-size: 30px;
    }
    h4{
	text-align: center;
	font-size: 30px;
    }
    
    body {
	text-align: center;
    }
    h6{
	
	font-size: 1.3em;
	text-align: center;
    }
    .smallcenter {
	display: block;
	margin-left: 15%;
	margin-right: auto;
	width: 30%;     
    }
    .apa-reference {
	padding-left: 36px;
	text-indent: -36px;
    }
    p{
	text-align: left;
	font-size: 25px;
	margin-left: 20%;

	margin-right: 20%;
    }
    div{
	margin-left: 27%;
	font-size: 10px;
	
    }
  </style>
  </head>
  <body>
  <h3></h3>
    <header>
      
      <nav>
	<ul>

	  <li><a href="../../index.html">Index</a></li>
	  <li><a href="../../aboutMe.html">About Me</a></li>
	  <li><a href="../../Pages/purpose.html">Purpose</a></li>
	  <li><a href="../../directory.html">Directory</a></li>
	  <li><a href="../../CS-I/CS-I.html">CS-I</a></li>
	  <li><a href="../../CS-II/CS-II.html">CS-II</a></li>
	  <li><a href="../CS-III.html">CS-III</a></li>
	  <li><a href="../../Stats/Stats.html">AP Stats</a></li>
	  <li><a href="../../references.html">References</a></li>
	</ul>
      </nav>
      <h1>Sorting Algorithm Comparison</h1>

    </header>
    <body>

        <section>
            <h2>Merge Sort</h2>
            <p>
                Merge Sort is a divide-and-conquer algorithm that divides an array into two halves, recursively sorts each half, and then merges the sorted halves.
                It has a time complexity of O(n log n) and a space complexity of O(n).
            </p>
        </section>
    
        <section>
            <h2>Quicksort</h2>
            <p>
                Quicksort is a divide-and-conquer algorithm that selects a 'pivot' element and partitions the array into two sub-arrays - elements less than the pivot and elements greater than the pivot.
                These sub-arrays are then recursively sorted. Quicksort has an average time complexity of O(n log n), but its worst-case time complexity can be O(n^2).
                It typically has better average performance than Merge Sort due to smaller constant factors. Its space complexity is O(log n) due to the recursive call stack.
            </p>
        </section>
    
        <section>
            <h2>Heapsort</h2>
            <p>
                Heapsort uses a binary heap data structure to build a heap and then repeatedly extracts the maximum element (in case of max-heap) to sort the array.
                It has a guaranteed worst-case time complexity of O(n log n) and a space complexity of O(1) since it sorts the array in place.
                However, constant factors in the runtime can make it slower than Merge Sort or Quicksort for small datasets.
            </p>
        </section>
    
        <section>
            <h2>Performance Comparison</h2>
            <p>
                - Merge Sort generally provides stable performance with its O(n log n) time complexity.
                - Quicksort is faster on average, but its worst-case time complexity can lead to performance degradation.
                - Heapsort is slower than the other two in practice due to constant factors, but it guarantees O(n log n) time complexity.
            </p>
        </section>
    
        <section>
            <h2>Space Complexity Comparison</h2>
            <p>
                - Merge Sort and Heapsort both have space complexities of O(n) and O(1) respectively, making them more memory-efficient for larger datasets.
                - Quicksort's space complexity varies depending on the implementation, but it generally requires O(log n) space for the recursive call stack.
            </p>
        </section>
    
        <footer>
            <h2>References</h2>
            <p>OpenAI. (2021). GPT-3.5 [Language model]. OpenAI. https://openai.com/</p>
        </footer>
    </body>
    </html>
 
